<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar@3x.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar@3x.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar@2x.png">
  <link rel="mask-icon" href="/images/avatar@3x.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xyhuangjia.gitee.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="::before 和 :after 的双冒号和单冒号有什么区别？（1）冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。注意： :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在C">
<meta property="og:type" content="article">
<meta property="og:title" content="css面试题">
<meta property="og:url" content="https://xyhuangjia.gitee.io/2024/07/18/css-interview/index.html">
<meta property="og:site_name" content="黄佳的博客">
<meta property="og:description" content="::before 和 :after 的双冒号和单冒号有什么区别？（1）冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。注意： :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在C">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-18T03:33:56.000Z">
<meta property="article:modified_time" content="2024-07-18T03:40:20.907Z">
<meta property="article:author" content="黄佳">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xyhuangjia.gitee.io/2024/07/18/css-interview/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>css面试题 | 黄佳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">黄佳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xyhuangjia.gitee.io/2024/07/18/css-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar@3x.png">
      <meta itemprop="name" content="黄佳">
      <meta itemprop="description" content="临渊羡鱼不如退而结网。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄佳的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          css面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-18 11:33:56 / 修改时间：11:40:20" itemprop="dateCreated datePublished" datetime="2024-07-18T11:33:56+08:00">2024-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="before-和-after-的双冒号和单冒号有什么区别？"><a href="#before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="::before 和 :after 的双冒号和单冒号有什么区别？"></a>::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>（1）冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。<br>（2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。<br><strong>注意：</strong> :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。</p>
<h3 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h3><p>(1)有空格时会有间隙，可以删除空格解决；<br>(2)margin正值时，可以让margin使用负值解决；<br>(3)使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决；</p>
<h3 id="Sass、Less-是什么？为什么要使用他们？"><a href="#Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="Sass、Less 是什么？为什么要使用他们？"></a>Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。</p>
<p>为什么要使用它们？</p>
<ul>
<li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h3 id="媒体查询的理解？"><a href="#媒体查询的理解？" class="headerlink" title="媒体查询的理解？"></a>媒体查询的理解？</h3><p>媒体查询（Media Queries）是CSS3引入的一个重要概念，它允许开发者根据不同的设备特性（如屏幕尺寸、分辨率、色彩深度、设备方向等）来应用特定的CSS样式规则。这使得网站能够提供更加优化的视觉体验，无论是在大屏幕的台式机、笔记本电脑上，还是在小屏幕的智能手机和平板电脑上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media [not] &lt;media_type&gt; and (&lt;media_feature&gt;: &lt;value&gt;) &#123;</span><br><span class="line">    <span class="comment">/* CSS rules */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中各个部分的含义如下：</p>
<ul>
<li><code>not</code> 是可选的关键词，用于否定媒体类型。</li>
<li><code>&lt;media_type&gt;</code> 是媒体类型，如 <code>all、print、screen</code> 等，表示目标输出设备的类型。</li>
<li><code>and</code> 连接符用于组合多个媒体特性。</li>
<li><code>&lt;media_feature&gt;</code> 是媒体特性，比如 <code>width、height、orientation、color</code> 等，它们描述了设备的物理属性。</li>
<li><code>&lt;value&gt;</code> 是与媒体特性相关的值，例如 <code>600px</code> 或者 <code>landscape</code><br>媒体查询是响应式设计的核心组成部分，它使得Web开发人员能够创建灵活、自适应的布局，以适应不断变化的设备生态系统。</li>
</ul>
<h3 id="对-CSS-工程化的理解"><a href="#对-CSS-工程化的理解" class="headerlink" title="对 CSS 工程化的理解"></a>对 CSS 工程化的理解</h3><p>CSS工程化是指在大型项目中，为了更好地管理和维护CSS代码，通过一系列的方法、工具和技术来组织、优化、构建和维护CSS的过程。随着前端项目的规模越来越大，CSS工程化变得尤为重要，它帮助开发者应对代码复用、模块化、性能优化、可维护性和团队协作等方面的挑战。</p>
<p>以下是CSS工程化的一些关键方面：</p>
<ol>
<li>宏观设计</li>
</ol>
<ul>
<li>目录结构：优化CSS文件的目录结构，通常按照功能模块或者页面组件进行分类，避免单一CSS文件过大。</li>
<li>模块化：将CSS代码划分为独立的模块，每个模块负责一个特定的功能或组件，减少样式间的依赖和冲突。</li>
<li>命名规范：采用一致的命名约定，如BEM（Block Element Modifier）、OOCSS（Object-Oriented CSS）或SMACSS（Scalable and Modular Architecture for CSS），以增强代码的可读性和可维护性。</li>
</ul>
<ol start="2">
<li>编码优化</li>
</ol>
<ul>
<li>预处理器：使用Sass、Less或Stylus等CSS预处理器，它们提供了变量、嵌套、函数和混合等功能，使CSS代码更具编程性。</li>
<li>代码简化：利用PostCSS插件自动添加浏览器前缀、优化选择器、移除冗余代码等，减少人工工作量并提高代码质量。</li>
</ul>
<ol start="3">
<li>构建流程</li>
</ol>
<ul>
<li>自动化构建：集成Webpack、Gulp或Grunt等工具，实现CSS的自动化构建，包括压缩、合并、前缀添加、源映射生成等，以优化最终的生产环境代码。</li>
<li>热更新：在开发环境中实时更新CSS，无需刷新页面即可看到样式更改的效果，提高开发效率。</li>
</ul>
<ol start="4">
<li>可维护性</li>
</ol>
<ul>
<li>文档：编写良好的文档和注释，确保代码易于理解和修改。</li>
<li>测试：使用视觉回归测试工具确保样式更改不会破坏现有设计。</li>
<li>版本控制：利用Git或其他版本控制系统管理CSS文件的更改历史，便于回滚和协作。</li>
</ul>
<ol start="5">
<li>性能优化</li>
</ol>
<ul>
<li>延迟加载：只在需要的时候加载特定的CSS，比如使用JavaScript按需加载样式。</li>
<li>关键路径CSS：将首屏渲染所需的CSS内联到HTML中，提高首屏加载速度。</li>
</ul>
<ol start="6">
<li>团队协作</li>
</ol>
<ul>
<li>代码审查：通过代码审查确保CSS遵循既定的规范和最佳实践。</li>
<li>共享资源：创建和维护一个共享的样式库或设计系统，确保团队成员使用统一的UI组件和样式。</li>
</ul>
<p>通过这些策略，CSS工程化不仅提高了代码的质量和性能，还促进了团队协作，降低了维护成本，使前端开发变得更加高效和可持续。</p>
<h3 id="如何判断元素是否到达可视区域"><a href="#如何判断元素是否到达可视区域" class="headerlink" title="如何判断元素是否到达可视区域"></a>如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p>
<ul>
<li><code>window.innerHeight</code> 是浏览器可视区的高度；</li>
<li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li>
<li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；<br>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop</code>;</li>
</ul>
<h3 id="z-index属性在什么情况下会失效"><a href="#z-index属性在什么情况下会失效" class="headerlink" title="z-index属性在什么情况下会失效"></a>z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>
<h3 id="CSS3中的transform有哪些属性"><a href="#CSS3中的transform有哪些属性" class="headerlink" title="CSS3中的transform有哪些属性"></a>CSS3中的transform有哪些属性</h3><p>CSS3的transform属性允许对元素进行变形操作，这包括旋转、缩放、倾斜和移动等效果。</p>
<h3 id="对Flex布局的理解及其使用场景"><a href="#对Flex布局的理解及其使用场景" class="headerlink" title="对Flex布局的理解及其使用场景"></a>对Flex布局的理解及其使用场景</h3><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义:</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p>
<h6 id="浮动元素引起的问题？"><a href="#浮动元素引起的问题？" class="headerlink" title="浮动元素引起的问题？"></a>浮动元素引起的问题？</h6><ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<h6 id="清除浮动的方式如下："><a href="#清除浮动的方式如下：" class="headerlink" title="清除浮动的方式如下："></a>清除浮动的方式如下：</h6><ul>
<li>给父级div定义height属性</li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式</li>
<li>包含浮动元素的父级标签添加overflow:hidden或者overflow:auto</li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li>
</ul>
<h4 id="使用-clear-属性清除浮动的原理？"><a href="#使用-clear-属性清除浮动的原理？" class="headerlink" title="使用 clear 属性清除浮动的原理？"></a>使用 clear 属性清除浮动的原理？</h4><p>在CSS中，clear属性用于指定元素的哪一侧不允许出现浮动元素。当一个元素周围有浮动元素时（即，使用了float属性的元素），该元素可能会与这些浮动元素重叠，或者被推到浮动元素后面。clear属性可以防止这种情况发生，确保元素在浮动元素之下或之后开始。</p>
<p>clear属性可以接受以下值：</p>
<ul>
<li>none：默认值，允许所有方向的浮动。</li>
<li>left：不允许左侧有浮动元素。</li>
<li>right：不允许右侧有浮动元素。</li>
<li>both：不允许左右两侧有浮动元素。</li>
<li>inline-start：不允许内联起始位置有浮动元素（在从右到左的书写模式下，这相当于不允许右侧有浮动元素）。</li>
<li>inline-end：不允许内联结束位置有浮动元素（在从右到左的书写模式下，这相当于不允许左侧有浮动元素）。<br>需要注意的是，clear属性只对块级元素生效，并且它会影响元素的垂直定位，但不会影响其水平位置。此外，在现代布局方法如Flexbox和Grid布局中，clear和float的使用已经减少，因为这些新方法提供了更强大、更灵活的布局控制。</li>
</ul>
<h3 id="对BFC的理解，如何创建BFC？"><a href="#对BFC的理解，如何创建BFC？" class="headerlink" title="对BFC的理解，如何创建BFC？"></a>对BFC的理解，如何创建BFC？</h3><p>BFC，全称 Block Formatting Context（块级格式化上下文），是CSS中一种重要的渲染规则，它决定了页面上块级元素如何布局以及它们与其他元素之间的相互作用。BFC可以看作是一个独立的容器，其中的元素不会受到外部元素的影响，同样，BFC外部的元素也不会受到BFC内部元素的影响，除非它们直接与BFC边缘接触。</p>
<p><strong>BFC的创建条件如下：</strong></p>
<ul>
<li>根元素（html）。</li>
<li>显式地使用overflow属性设置为非visible的值（如auto，scroll，hidden）的元素。</li>
<li>显式地使用display: flex或display: grid的元素。</li>
<li>显式地使用float属性（除了none）的元素。</li>
<li>显式地使用position: absolute或position: fixed的元素。</li>
<li>显式地使用display: inline-block或display: table-cell的元素。</li>
</ul>
<p><strong>BFC的主要特性包括：</strong></p>
<ul>
<li>隔离性：BFC内部的元素不会影响到BFC外部的元素，反之亦然。</li>
<li>浮动元素的影响：在BFC内部，浮动元素不会影响到后续的块级元素。在BFC边界之内，浮动元素会按照正常的流布局排列。</li>
<li>高度计算：BFC的高度会包含其内部的浮动元素，这样父元素就可以正确地计算其高度，避免高度塌陷的问题。</li>
<li>清除浮动：BFC可以用来清除浮动，使得内部的元素能够紧贴在底部而不会被浮动元素遮挡。</li>
<li>布局：BFC中的块级元素会按照自上而下的顺序堆叠，而不会与同级的其他BFC中的元素交互。</li>
</ul>
<p>创建BFC的一个常见用途是解决浮动元素导致的父元素高度塌陷问题。通过将父元素设置为BFC（比如使用overflow: auto），可以确保父元素包含其内部的浮动子元素，从而正确地计算高度。</p>
<p>例如，为了防止高度塌陷，可以这样做：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto; <span class="comment">/* 或者使用 other values like &#x27;hidden&#x27;, &#x27;scroll&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span>Floating element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Other elements --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在现代布局技术（如Flexbox和Grid）中，BFC的概念仍然重要，但实现布局的方式更为简单和直观。然而，在处理遗留代码或特定布局需求时，理解BFC的工作原理仍然是非常有用的。</p>
<h3 id="什么是margin重叠问题？如何解决？"><a href="#什么是margin重叠问题？如何解决？" class="headerlink" title="什么是margin重叠问题？如何解决？"></a>什么是margin重叠问题？如何解决？</h3><p>在CSS布局中，margin重叠问题，也称为margin折叠（margin collapsing）或margin合并，指的是当两个相邻的块级元素的上外边距（margin-top）和下外边距（margin-bottom）遇到彼此时，它们不会简单相加，而是合并成一个单一的外边距，这个外边距的大小通常是这两个外边距中的最大值。</p>
<p>Margin重叠的几种情况：</p>
<ul>
<li>相邻元素的margin重叠：当一个元素的下外边距与下一个元素的上外边距相遇时，它们会重叠。</li>
<li>元素与其父元素的margin重叠：当一个元素的上外边距与父元素的上外边距相遇时，它们可能重叠；同样的逻辑适用于下外边距。</li>
<li>空元素的margin重叠：如果一个元素没有内容、内边距或边框，那么它的顶部和底部外边距可能会重叠。<br>解决Margin重叠的方法：</li>
<li>使用border或padding：即使是最小的边框（border）或内边距（padding）也可以阻止margin折叠，因为这些属性会打断外边距的连续性，防止它们重叠。  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="comment">/* 透明边框也可以防止margin折叠 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建新的BFC（Block Formatting Context）：BFC是一个独立的布局环境，其中的元素不会与外部元素的margin发生重叠。可以通过以下方式之一创建BFC：<ul>
<li>设置overflow为auto、scroll或hidden。</li>
<li>使用display: flex或display: grid。</li>
<li>使用float属性（非none）。</li>
<li>使用position: absolute或position: fixed。</li>
<li>使用display: inline-block或display: table-cell。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">overflow</span>: auto; <span class="comment">/* 创建一个新的BFC */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用伪元素：在元素之前或之后添加伪元素（:before或:after），并设置一些高度或边框，也可以防止margin折叠。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用负margin：虽然不是直接解决问题，但有时使用负margin可以帮助调整布局以达到预期的效果。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">深色版本</span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: -<span class="number">10px</span>; <span class="comment">/* 负margin */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
选择哪种方法取决于具体的布局需求和场景。在复杂布局中，理解和控制margin折叠可以避免布局出现意外的变化。</li>
</ul>
</li>
</ul>
<h3 id="position的属性有哪些，区别是什么"><a href="#position的属性有哪些，区别是什么" class="headerlink" title="position的属性有哪些，区别是什么"></a>position的属性有哪些，区别是什么</h3><p>CSS 中的 position 属性用于控制元素的定位方式，它有五个主要的值，每个值定义了元素不同的定位行为。以下是这些值及其主要区别：</p>
<ul>
<li>static:<ul>
<li>这是 position 的默认值。</li>
<li>元素按照文档流的正常顺序排列，没有定位。</li>
<li>top, right, bottom, left 和 z-index 属性对静态定位的元素没有效果。</li>
</ul>
</li>
<li>relative:<ul>
<li>元素相对于它在文档流中的正常位置进行定位。</li>
<li>可以使用 top, right, bottom, left 属性来指定偏移量。</li>
<li>元素仍然占据空间，不会影响其他元素的位置。</li>
<li>不会创建新的层叠上下文，但可以改变自身的 z-index 值。</li>
</ul>
</li>
<li>absolute:<ul>
<li>元素脱离文档流，相对于最近的已定位祖先元素（即 position 不是 static 的祖先）定位。</li>
<li>如果没有已定位的祖先元素，则相对于初始包含块（通常是 <html> 元素）定位。</li>
<li>使用 top, right, bottom, left 属性确定位置。</li>
<li>不占据文档流中的空间，其他元素会占据其原本位置。</li>
<li>创建新的层叠上下文。</li>
</ul>
</li>
<li>fixed:<ul>
<li>类似于 absolute，但元素相对于浏览器窗口定位，即使页面滚动，元素位置不变。</li>
<li>同样使用 top, right, bottom, left 属性确定位置。</li>
<li>不占据文档流中的空间。</li>
<li>创建新的层叠上下文。</li>
</ul>
</li>
<li>sticky:<ul>
<li>元素在跨越特定边界前表现为 static，一旦到达边界则表现为 fixed。</li>
<li>边界由 top, right, bottom, left 属性确定。</li>
<li>当页面滚动过边界后，元素会“粘贴”在该位置，直到离开另一个边界。</li>
<li>在某些情况下，可能需要指定一个 height 或 max-height 来确保正确的行为。</li>
</ul>
</li>
</ul>
<p>每个 position 属性值都有其特定的用途和应用场景。例如，relative 常用于微调元素位置而不影响布局，absolute 和 fixed 用于创建弹出窗口、侧边栏或其他需要精确控制位置的元素，而 sticky 则用于创建随滚动显示和隐藏的导航条等。理解这些定位类型是CSS布局的关键部分。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/18/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="prev" title="原型和原型链">
      <i class="fa fa-chevron-left"></i> 原型和原型链
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/18/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="javaScript面试题">
      javaScript面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#before-%E5%92%8C-after-%E7%9A%84%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">::before 和 :after 的双冒号和单冒号有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#display-inline-block-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%98%BE%E7%A4%BA%E9%97%B4%E9%9A%99%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">display:inline-block 什么时候会显示间隙？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sass%E3%80%81Less-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">Sass、Less 是什么？为什么要使用他们？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">媒体查询的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-CSS-%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">对 CSS 工程化的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%88%B0%E8%BE%BE%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F"><span class="nav-number">6.</span> <span class="nav-text">如何判断元素是否到达可视区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#z-index%E5%B1%9E%E6%80%A7%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="nav-number">7.</span> <span class="nav-text">z-index属性在什么情况下会失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS3%E4%B8%AD%E7%9A%84transform%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">CSS3中的transform有哪些属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9Flex%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">9.</span> <span class="nav-text">对Flex布局的理解及其使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">1. 为什么需要清除浮动？清除浮动的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">浮动元素引起的问题？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">10.0.0.2.</span> <span class="nav-text">清除浮动的方式如下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-clear-%E5%B1%9E%E6%80%A7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">使用 clear 属性清除浮动的原理？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BABFC%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">对BFC的理解，如何创建BFC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmargin%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">什么是margin重叠问题？如何解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">13.</span> <span class="nav-text">position的属性有哪些，区别是什么</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="黄佳"
      src="/images/avatar@3x.png">
  <p class="site-author-name" itemprop="name">黄佳</p>
  <div class="site-description" itemprop="description">临渊羡鱼不如退而结网。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xyhuangjia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xyhuangjia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xyhuangjia@gmail.com" title="E-Mail → mailto:xyhuangjia@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备20008595号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄佳</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
